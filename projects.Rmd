---
title: "Code & Resources"
author: "Albert Vill"
date: ""
output: html_document
---
[![](https://github-readme-stats.vercel.app/api/pin/?username=acvill&repo=bracken_plot&bg_color=21436e&text_color=ededed&title_color=30ff53&hide_border=true&icon_color=ededed)](https://github.com/acvill/bracken_plot)

<details>
  <summary>Expand details...</summary>

As a graduate student studying metagenomics, I frequently use Derrick Wood's [Kraken2](https://doi.org/10.1186/s13059-019-1891-0) software for accurate and lightning-fast classification of short reads. [Bracken](https://doi.org/10.7717/peerj-cs.104) is complimentary software that uses Kraken reports to produce genus- and species-level abundance estimates. Often, a first step in metagenomic analysis is examining the distribution of different organisms across samples. To that end, I've created a [simple shiny app](https://acvill.shinyapps.io/bracken_plot/) for quick, customizable plotting of taxonomic structures encoded in multi-sample Bracken reports. 

<center>

![Example output from the bracken_plot app showing genus-level relative abudance across oral microbiome samples. Don't mind the human read contamination!](/img/about/bracken_barplot.png "Bracken bar plot"){ width=75% }

</center>
</details>

[![](https://github-readme-stats.vercel.app/api/pin/?username=acvill&repo=nodeSeqs&bg_color=21436e&text_color=ededed&title_color=30ff53&hide_border=true&icon_color=ededed)](https://github.com/acvill/nodeSeqs)

<details>
  <summary>Expand details...</summary>

[metaSPAdes](https://dx.doi.org/10.1101%2Fgr.213959.116) is a popular tool for assembling short reads from microbiomes. My simplified understanding of short-read de Bruijn graph assemblers is that they fail where ambiguous paths cannot be resolved. While it can be said that these points of failure may be due to certain **structural** features of the underlying sequences -- long repeats or conserved sequences found at multiple loci -- I am interested in the **functional** classification of sequences that occur at nodes on assembly graphs. Put another way, what kinds of genes are poorly represented in metagenomes because they are poorly assembled? From first principles, you might expect pieces of mobile elements like transposases and integrases to be on such a list of genes, since they are often flanked by repeated sequences and present in many copies across different genomic contexts. However, I wanted to take an empirical approach.

nodeSeqs.sh takes in a [**G**raphical **F**ragment **A**ssembly file](http://gfa-spec.github.io/GFA-spec/GFA1.html) and outputs sequences proximal to high-degree nodes. In the language of GFA, this script looks for *segments* that have a large number of *links*, and then filters those segments by *k*-mer coverage to preclude hits that are poorly assembled due to low coverage. The resulting fasta can then be fed into your favorite sequence alignment software.  

<center>

![A partial Bandage graph for a plasmidome assembly shows segments connected by links](/img/about/bandage_sub.svg "Bandage Graph"){ width=75% }

</center>

[See my related post on Bioinformatics Stack Exchange.](https://bioinformatics.stackexchange.com/questions/18476/)

</details>

[![](https://github-readme-stats.vercel.app/api/pin/?username=acvill&repo=findMotifs&bg_color=21436e&text_color=ededed&title_color=30ff53&hide_border=true&icon_color=ededed)](https://github.com/acvill/findMotifs)

<details>
  <summary>Expand details...</summary>
  
To understand the genetic context and biological relevance of DNA motifs, it's often valuable to analyze their distribution and sequence conservation. Many programs exist for both the identification of novel motifs and the scoring of known motifs, though few of these tools work out-of-the-box for highly fragmented bacterial genomes. To address this, I've written findMotifs.R -- an easy-to-implement R script to find and score short sequences using position-frequency matrices (PFMs). Given a set of contigs and a list of PFMs, this script returns an easy-to-parse table containing the sequence, score, and strand-wise position of each match above a user-defined threshold. findMotifs.R requires R version 4.0 and three packages: Biostrings, optparse, and stringr.

<center>

![findmotifs.R is invoked from the command line with user inputs. Progress for each motif prints to the console.](/img/about/findmotifs2.PNG "command line screenshot of findMotifs in action"){ width=75% }

</center>
</details>

<style>
p.caption {
  font-size: 0.9em;
  text-align: center;
  color: #7f1cad;
  margin-right: 10%;
  margin-left: 10%;
}
details > summary {
  font-size: 1.1em;
  padding: 0px;
  background-color: #FFFFFF;
  border: none;
  box-shadow: 0px 0px 0px #bbbbbb;
  cursor: pointer;
  margin-left: 5%;
  color: #21436e;
  border-radius: 5px;
}
</style>

